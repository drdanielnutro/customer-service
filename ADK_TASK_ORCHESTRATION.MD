# ADK_TASK_ORCHESTRATION.md

## ADK Migration Task Management System

This document provides specific guidance for Claude Code when orchestrating ADK migration tasks from `tasks.json`.

### üìã Also See
- **CLAUDE.md**: General subagent orchestration guide
- **executor-codigo instructions**: Subagent execution details

## Overview

You are responsible for:
1. **Managing task state** (pending ‚Üí in_progress ‚Üí done/failed)
2. **Orchestrating the executor-codigo** subagent
3. **Tracking progress** and dependencies
4. **Reporting overall status**

## Task State Management

### States
- `pending`: Not started
- `in_progress`: Currently being executed by executor-codigo
- `done`: Successfully completed
- `failed`: Execution failed (may retry)
- `blocked`: Dependencies not met

### State Transition Rules
```
pending ‚Üí in_progress ‚Üí done
                     ‚Üò failed ‚Üí pending (retry)
                     
pending ‚Üí blocked (if dependencies not met)
blocked ‚Üí pending (when dependencies complete)
```

## Orchestration Workflow

### 1. Initialize Task Tracking
```python
# Pseudo-code for your mental model
task_states = {
    1: {"status": "pending", "attempts": 0, "last_error": None},
    2: {"status": "pending", "attempts": 0, "last_error": None},
    # ... for all tasks in tasks.json
}
```

### 2. Task Selection Algorithm
1. **Check dependencies first**
   - Only select tasks where all dependencies have status "done"
   - Mark tasks with unmet dependencies as "blocked"

2. **Priority order**
   - High priority tasks first
   - Within same priority, use task ID order

3. **Skip conditions**
   - Status is "done"
   - Status is "in_progress" 
   - Status is "blocked"
   - Attempts >= 3 (mark as "failed" permanently)

### 3. Execution Protocol

```markdown
## For each selected task:

1. **Update state to "in_progress"**
   - Record timestamp
   - Increment attempt counter

2. **Prepare executor-codigo invocation**
   ```
   Use the executor-codigo agent to execute task {id}: {title}
   
   Task details:
   {full task JSON from tasks.json}
   ```

3. **Process executor response**
   - Parse the JSON response
   - Update task state based on response.status:
     - "success" ‚Üí "done"
     - "failed" ‚Üí "failed" (may retry if attempts < 3)
     - "partial" ‚Üí "failed" (requires investigation)

4. **Record execution details**
   - Files modified
   - Issues found
   - Verification steps
```

## Progress Reporting

After each task execution, provide a status update:

```markdown
## ADK Migration Progress

**Overall**: {completed}/{total} tasks completed

### Recent Activity
‚úÖ Task {id}: {title} - COMPLETED
   - Files modified: {list}
   - Verification: {method}

### Current Status
üîÑ In Progress: {count}
‚úÖ Completed: {count}
‚ùå Failed: {count}
üîí Blocked: {count}
‚è≥ Pending: {count}

### Next Tasks
1. Task {id}: {title} (Priority: {priority})
2. Task {id}: {title} (Priority: {priority})
```

## Dependency Management

### Checking Dependencies
```python
def can_execute_task(task_id, task_states, tasks):
    task = tasks[task_id]
    dependencies = task.get("dependencies", [])
    
    for dep_id in dependencies:
        if task_states[dep_id]["status"] != "done":
            return False, f"Blocked by task {dep_id}"
    
    return True, "Ready"
```

### Common Dependency Patterns
- Task 1 (config.py) ‚Üí Tasks 2-5 depend on it
- Task 2 (agent.py) ‚Üí Most tool updates depend on it
- Task 6 (artifact_handler) ‚Üí Task 7 documentation depends on it

## Error Handling

### When executor-codigo reports failure:

1. **Analyze the error**
   - File not found ‚Üí Check if previous tasks created it
   - Content mismatch ‚Üí May need manual inspection
   - Syntax error ‚Üí Task instructions may be incomplete

2. **Retry logic**
   - Attempts < 3: Mark as "failed", will retry
   - Attempts >= 3: Mark as "failed" permanently, skip

3. **Report to user**
   ```markdown
   ‚ö†Ô∏è Task {id} failed: {error_summary}
   - Attempt: {current}/{max}
   - Issue: {specific_issue}
   - Suggestion: {what_user_should_do}
   ```

## Best Practices

### DO:
- ‚úÖ Always update task state before and after execution
- ‚úÖ Check dependencies before attempting execution
- ‚úÖ Provide clear progress updates
- ‚úÖ Include verification steps in reports
- ‚úÖ Track which files were modified by each task

### DON'T:
- ‚ùå Execute tasks with unmet dependencies
- ‚ùå Retry more than 3 times
- ‚ùå Execute multiple tasks simultaneously
- ‚ùå Skip progress reporting
- ‚ùå Ignore executor-codigo error messages

## Quick Commands

### Start migration
```
"Execute ADK migration tasks from tasks.json"
```

### Check status
```
"Show ADK migration progress"
```

### Retry failed tasks
```
"Retry failed ADK tasks"
```

### Execute specific task
```
"Execute ADK task {id}"
```

## Integration with CLAUDE.md

This workflow integrates with the general orchestration patterns:

1. **You** (Claude Code) manage the overall workflow
2. **executor-codigo** executes individual tasks
3. **Other subagents** can be called for validation:
   - Use `adk-tool-compatibility-analyzer` after tool modifications
   - Use `gemini-api-compliance-auditor` after API changes
   - Use `validador-tasks-adk` before starting to validate feasibility

## State Persistence Note

Remember: You don't have persistent memory between conversations. When resuming:
1. Read tasks.json to see the task list
2. Check modified files to infer completed tasks
3. Ask user about current state if unclear
4. Resume from appropriate point

---

**Priority**: When user mentions "ADK migration tasks", "execute tasks from tasks.json", or similar, follow this orchestration protocol.