{
  "project": "professor-virtual-adk-compliance",
  "description": "Immediate implementation tasks for updating the Professor Virtual system to comply with Google ADK standards.\n\n## Resumo das Mudanças Críticas\n1. **Todas as funções de tools devem ser `async`**\n2. **Usar `await` com `load_artifact()` e `save_artifact()`**\n3. **Nunca usar `session.get_artifact()` ou `session.create_artifact()`**\n4. **Configurar `artifact_service` no Runner**\n5. **Frontend envia base64, backend cria artifacts explicitamente**\n6. **Acessar dados via `artifact.inline_data.data`**\n\n## Ordem de Implementação Recomendada\n1. Atualizar `config.py` com novas configurações\n2. Modificar `agent.py` para incluir Runner e artifact_service\n3. Tornar todas as funções de tools assíncronas\n4. Substituir APIs deprecated nos tools\n5. Criar `artifact_handler.py` para gerenciar uploads\n6. Revisar e atualizar funções auxiliares\n7. Documentar integração com frontend",
  "created_at": "2025-01-30",
  "tasks": [
    {
      "id": 1,
      "title": "Update config.py with artifact_service and GCS configurations",
      "description": "Add configuration fields for artifact_service and GCS storage to support proper ADK integration",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "PROBLEMA: Falta configuração do artifact_service e GCS\n\nREMOVER/ADICIONAR após a linha 38:\n```python\n    API_KEY: str | None = Field(default=\"\")\n```\n\nADICIONAR:\n```python\n    API_KEY: str | None = Field(default=\"\")\n    \n    # Configurações do Artifact Service\n    artifact_storage_type: str = Field(default=\"memory\", description=\"memory ou gcs\")\n    gcs_bucket_name: str = Field(default=\"adk-professor-virtual-artifacts\")\n    \n    # Configuração de ambiente\n    is_production: bool = Field(default=False)\n```",
      "testStrategy": "Verify that config.py contains the new fields (artifact_storage_type, gcs_bucket_name, is_production) and that they can be properly imported and used in agent.py",
      "started_at": "2025-07-30T17:21:40Z",
      "completed_at": "2025-07-30T17:21:49Z",
      "files_modified": [
        "professor-virtual/professor_virtual/config.py"
      ]
    },
    {
      "id": 2,
      "title": "Modify agent.py to include Runner and artifact_service initialization",
      "description": "Update agent.py to properly initialize the Runner with artifact_service and session_service according to ADK standards",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "PROBLEMA: Falta inicialização do artifact_service no Runner\n\n❌ CÓDIGO ATUAL (linhas 24-40):\n```python\nroot_agent = Agent(\n    model=configs.agent_settings.model,\n    global_instruction=\"\",\n    instruction=INSTRUCTION,\n    name=configs.agent_settings.name,\n    tools=[\n        transcrever_audio,\n        analisar_necessidade_visual,\n        analisar_imagem_educacional,\n        gerar_audio_tts,\n    ],\n    generate_content_config=configs.generate_content_config,\n    before_tool_callback=before_tool,\n    after_tool_callback=after_tool,\n    before_agent_callback=before_agent,\n    before_model_callback=rate_limit_callback,\n)\n```\n\n✅ SUBSTITUIR POR:\n```python\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom google.adk.artifacts import InMemoryArtifactService, GcsArtifactService\n\n# Configurar artifact service baseado no ambiente\nif configs.is_production and configs.artifact_storage_type == \"gcs\":\n    artifact_service = GcsArtifactService(bucket_name=configs.gcs_bucket_name)\nelse:\n    artifact_service = InMemoryArtifactService()\n\n# Configurar session service\nsession_service = InMemorySessionService()\n\n# Criar o agente\nroot_agent = Agent(\n    model=configs.agent_settings.model,\n    global_instruction=\"\",\n    instruction=INSTRUCTION,\n    name=configs.agent_settings.name,\n    tools=[\n        transcrever_audio,\n        analisar_necessidade_visual,\n        analisar_imagem_educacional,\n        gerar_audio_tts,\n    ],\n    generate_content_config=configs.generate_content_config,\n    before_tool_callback=before_tool,\n    after_tool_callback=after_tool,\n    before_agent_callback=before_agent,\n    before_model_callback=rate_limit_callback,\n)\n\n# Criar o Runner com artifact service\nrunner = Runner(\n    agent=root_agent,\n    app_name=configs.app_name,\n    session_service=session_service,\n    artifact_service=artifact_service  # CRÍTICO: Deve ser configurado\n)\n```",
      "testStrategy": "Verify that agent.py imports Runner, InMemorySessionService, InMemoryArtifactService, and GcsArtifactService; initializes artifact_service based on environment config; creates session_service; and properly initializes the Runner with all required services",
      "started_at": "2025-07-30T17:34:47Z",
      "completed_at": "2025-07-30T17:35:27Z",
      "files_modified": [
        "professor-virtual/professor_virtual/agent.py"
      ]
    },
    {
      "id": 3,
      "title": "Update analisar_imagem_educacional.py to be async and fix deprecated APIs",
      "description": "Convert analisar_imagem_educacional function to async and fix deprecated session.get_artifact API and incorrect artifact data access",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "### PROBLEMA 1: API inexistente `session.get_artifact`\n\n**❌ REMOVER (linhas 48-51):**\n```python\n        # Obter artefato - mantém lógica original\n        artifact = tool_context.session.get_artifact(nome_artefato_imagem)\n        if not artifact:\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n        # Obter artefato usando API correta\n        artifact = await tool_context.load_artifact(nome_artefato_imagem)\n        if not artifact:\n```\n\n### PROBLEMA 2: Função deve ser assíncrona\n\n**❌ REMOVER (linha 42):**\n```python\ndef analisar_imagem_educacional(nome_artefato_imagem: str, contexto_pergunta: str, tool_context: ToolContext) -> Dict[str, Any]:\n```\n\n**✅ SUBSTITUIR POR:**\n```python\nasync def analisar_imagem_educacional(nome_artefato_imagem: str, contexto_pergunta: str, tool_context: ToolContext) -> Dict[str, Any]:\n```\n\n### PROBLEMA 3: Acesso incorreto aos dados do artifact\n\n**❌ REMOVER (linha 57):**\n```python\n        imagem_bytes = artifact.content\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n        # Extrair dados do artifact corretamente\n        if hasattr(artifact, 'inline_data') and artifact.inline_data:\n            imagem_bytes = artifact.inline_data.data\n            mime_type = artifact.inline_data.mime_type\n        else:\n            return {\n                \"erro\": \"Formato de artifact inválido\",\n                \"sucesso\": False,\n                \"qualidade_adequada\": False\n            }\n```",
      "testStrategy": "Verify that analisar_imagem_educacional function is async, uses await tool_context.load_artifact() instead of session.get_artifact(), and correctly accesses artifact data through artifact.inline_data.data with proper error handling for invalid artifact formats",
      "started_at": "2025-07-30T17:42:35Z",
      "completed_at": "2025-07-30T17:44:09Z",
      "files_modified": [
        "professor-virtual/professor_virtual/tools/analisar_imagem_educacional/analisar_imagem_educacional.py"
      ]
    },
    {
      "id": 4,
      "title": "Update gerar_audio_tts.py to be async and fix deprecated APIs",
      "description": "Convert gerar_audio_tts function to async and fix deprecated session.create_artifact API usage",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "### PROBLEMA 1: API inexistente `session.create_artifact`\n\n**❌ REMOVER (linhas 119-124):**\n```python\n        # Salvar usando a API existente do projeto\n        tool_context.session.create_artifact(\n            name=nome_artefato,\n            content=audio_bytes,\n            mime_type=\"audio/mpeg\"\n        )\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n        # Salvar usando a API correta do ADK\n        audio_part = types.Part.from_data(\n            data=audio_bytes,\n            mime_type=\"audio/mpeg\"\n        )\n        version = await tool_context.save_artifact(nome_artefato, audio_part)\n```\n\n### PROBLEMA 2: Função deve ser assíncrona\n\n**❌ REMOVER (linha 41):**\n```python\ndef gerar_audio_tts(texto: str, tool_context: ToolContext, velocidade: float = 1.0, voz: str = \"pt-BR-Standard-A\") -> Dict[str, Any]:\n```\n\n**✅ SUBSTITUIR POR:**\n```python\nasync def gerar_audio_tts(texto: str, tool_context: ToolContext, velocidade: float = 1.0, voz: str = \"pt-BR-Standard-A\") -> Dict[str, Any]:\n```\n\n### PROBLEMA 3: Adicionar versão no retorno\n\n**❌ REMOVER (linhas 142-148):**\n```python\n        return {\n            \"sucesso\": True,\n            \"nome_artefato_gerado\": nome_artefato,\n            \"tamanho_caracteres\": len(texto),\n            \"tamanho_bytes\": len(audio_bytes),\n            \"voz_utilizada\": gemini_voice,\n            \"velocidade\": velocidade\n        }\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n        return {\n            \"sucesso\": True,\n            \"nome_artefato_gerado\": nome_artefato,\n            \"versao\": version,  # Adicionar versão retornada\n            \"tamanho_caracteres\": len(texto),\n            \"tamanho_bytes\": len(audio_bytes),\n            \"voz_utilizada\": gemini_voice,\n            \"velocidade\": velocidade\n        }\n```",
      "testStrategy": "Verify that gerar_audio_tts function is async, uses await tool_context.save_artifact() with types.Part.from_data() instead of session.create_artifact(), and includes version field in the return object",
      "started_at": "2025-07-30T17:57:22.033720Z",
      "completed_at": "2025-07-30T18:02:14.438395Z",
      "files_modified": [
        "professor-virtual/professor_virtual/tools/gerar_audio_tts/gerar_audio_tts.py"
      ]
    },
    {
      "id": 5,
      "title": "Update transcrever_audio.py to be async and fix deprecated APIs",
      "description": "Convert transcrever_audio function to async and fix deprecated artifact loading/saving APIs, including updating the auxiliary function _buscar_audio_na_mensagem",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "### PROBLEMA 1: Método deve ser assíncrono\n\n**❌ REMOVER (linha 46):**\n```python\ndef transcrever_audio(\n```\n\n**✅ SUBSTITUIR POR:**\n```python\nasync def transcrever_audio(\n```\n\n### PROBLEMA 2: load_artifact deve usar await\n\n**❌ REMOVER (linha 61):**\n```python\n        audio_artifact = tool_context.load_artifact(nome_artefato_audio)\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n        audio_artifact = await tool_context.load_artifact(nome_artefato_audio)\n```\n\n### PROBLEMA 3: save_artifact deve usar await\n\n**❌ REMOVER (linha 151):**\n```python\n            versao_salva = tool_context.save_artifact(filename, transcript_artifact)\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n            versao_salva = await tool_context.save_artifact(filename, transcript_artifact)\n```\n\n### PROBLEMA 4: Função auxiliar _buscar_audio_na_mensagem\n\n**❌ REMOVER (linha 227):**\n```python\ndef _buscar_audio_na_mensagem(tool_context: ToolContext) -> Optional[Any]:\n```\n\n**✅ SUBSTITUIR POR:**\n```python\nasync def _buscar_audio_na_mensagem(tool_context: ToolContext) -> Optional[Any]:\n```\n\n**❌ REMOVER (linha 65):**\n```python\n            audio_artifact = _buscar_audio_na_mensagem(tool_context)\n```\n\n**✅ SUBSTITUIR POR:**\n```python\n            audio_artifact = await _buscar_audio_na_mensagem(tool_context)\n```",
      "testStrategy": "Verify that transcrever_audio function is async, uses await with tool_context.load_artifact() and tool_context.save_artifact(), the auxiliary function _buscar_audio_na_mensagem is also async, and all calls to _buscar_audio_na_mensagem use await",
      "started_at": "2025-07-30T18:19:10Z",
      "completed_at": "2025-07-30T18:21:55Z",
      "files_modified": [
        "professor-virtual/professor_virtual/tools/transcrever_audio/transcrever_audio.py"
      ]
    },
    {
      "id": 6,
      "title": "Create artifact_handler.py for managing frontend uploads",
      "description": "Create a new file to handle file uploads from frontend and create artifacts following ADK standards",
      "status": "pending",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "Novo Arquivo Necessário: `professor_virtual/artifact_handler.py`\n\nCriar este arquivo para gerenciar uploads do frontend:\n\n```python\n\"\"\"Handler para processar uploads e criar artifacts do frontend.\"\"\"\n\nimport base64\nfrom typing import Dict, Any\nfrom google.genai import types\nfrom google.adk.agents.invocation_context import InvocationContext\n\n\nasync def handle_file_upload(\n    file_data: Dict[str, Any],\n    context: InvocationContext\n) -> Dict[str, Any]:\n    \"\"\"\n    Processa upload de arquivo do frontend e cria artifact.\n    \n    Args:\n        file_data: Dict com 'content' (base64), 'mime_type' e 'filename'\n        context: Contexto da invocação ADK\n        \n    Returns:\n        Dict com informações do artifact criado\n    \"\"\"\n    try:\n        # Decodificar base64 se necessário\n        if isinstance(file_data['content'], str):\n            content_bytes = base64.b64decode(file_data['content'])\n        else:\n            content_bytes = file_data['content']\n            \n        # Criar Part do arquivo\n        artifact = types.Part.from_data(\n            data=content_bytes,\n            mime_type=file_data['mime_type']\n        )\n        \n        # Salvar artifact\n        version = await context.save_artifact(\n            filename=file_data['filename'],\n            artifact=artifact\n        )\n        \n        return {\n            \"success\": True,\n            \"filename\": file_data['filename'],\n            \"version\": version,\n            \"size\": len(content_bytes)\n        }\n        \n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n```",
      "testStrategy": "Verify that artifact_handler.py exists in professor_virtual directory, contains handle_file_upload async function with proper imports (base64, types from google.genai, InvocationContext), handles base64 decoding, creates artifacts using types.Part.from_data(), saves artifacts with context.save_artifact(), and returns success/error responses with proper fields"
    },
    {
      "id": 7,
      "title": "Frontend Integration Guidelines (Documentation/Comments)",
      "description": "Document the frontend integration requirements and data format specifications for proper communication with the ADK backend",
      "status": "pending",
      "dependencies": [
        6
      ],
      "priority": "high",
      "details": "## Modificações no Frontend (Orientações)\n\n### Frontend deve enviar dados no formato:\n\n```json\n{\n  \"action\": \"upload_file\",\n  \"file_data\": {\n    \"content\": \"base64_encoded_content\",\n    \"mime_type\": \"audio/wav\",\n    \"filename\": \"pergunta_aluno_123.wav\"\n  },\n  \"session_id\": \"session_abc\",\n  \"user_id\": \"user_123\"\n}\n```\n\n### Frontend NÃO deve:\n- Esperar que o Runner crie artifacts automaticamente\n- Enviar arquivos binários diretamente no corpo da requisição\n- Usar APIs do ADK diretamente (não há SDK Flutter oficial)\n\n### Frontend DEVE:\n- Converter arquivos para base64 antes de enviar\n- Incluir sempre o MIME type correto\n- Aguardar confirmação com filename e version do backend",
      "testStrategy": "Verify that frontend code (when implemented) follows these guidelines: sends data in the specified JSON format with base64 encoding, includes all required fields (action, file_data with content/mime_type/filename, session_id, user_id), does not expect automatic artifact creation, does not send binary data directly, and properly waits for backend confirmation with filename and version"
    },
    {
      "id": 11,
      "title": "Review and update all helper functions and callbacks for async/await compliance",
      "description": "Ensure all internal helper functions and callbacks that interact with artifacts are properly converted to async and use await, as this is a critical step not covered by the main tool file modifications.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        5
      ],
      "priority": "high",
      "details": "### Verificação **await** em helpers\n\nAlém dos arquivos listados, revise **todos** os *helpers* internos e callbacks para garantir:\n\n* funções que chamam `load_artifact` / `save_artifact` → `async def …`\n* chamadas precedidas de `await`\n\n> **Checklist rápido**\n>\n> * [_buscar_audio_na_mensagem] ✅ já alterado\n> * [_get_audio_hash] — permanece síncrono (não faz I/O)\n> * qualquer callback em `before_tool` / `after_tool` que use artifacts → tornar async",
      "testStrategy": "Manually review all helper functions and callbacks (e.g., in `before_tool`, `after_tool`) to confirm that any function calling `load_artifact` or `save_artifact` is defined as `async def` and that the calls are preceded by `await`. Verify that `_get_audio_hash` remains synchronous as specified."
    }
  ]
}