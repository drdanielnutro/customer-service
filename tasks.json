{
    "project": "professor-virtual-adk-compliance",
    "description": "Immediate implementation tasks for updating the Professor Virtual system to comply with Google ADK standards.\n\n## Resumo das Mudan\u00e7as Cr\u00edticas\n1. **Todas as fun\u00e7\u00f5es de tools devem ser `async`**\n2. **Usar `await` com `load_artifact()` e `save_artifact()`**\n3. **Nunca usar `session.get_artifact()` ou `session.create_artifact()`**\n4. **Configurar `artifact_service` no Runner**\n5. **Frontend envia base64, backend cria artifacts explicitamente**\n6. **Acessar dados via `artifact.inline_data.data`**\n\n## Ordem de Implementa\u00e7\u00e3o Recomendada\n1. Atualizar `config.py` com novas configura\u00e7\u00f5es\n2. Modificar `agent.py` para incluir Runner e artifact_service\n3. Tornar todas as fun\u00e7\u00f5es de tools ass\u00edncronas\n4. Substituir APIs deprecated nos tools\n5. Criar `artifact_handler.py` para gerenciar uploads\n6. Revisar e atualizar fun\u00e7\u00f5es auxiliares\n7. Documentar integra\u00e7\u00e3o com frontend",
    "created_at": "2025-01-30",
    "tasks": [
        {
            "id": 1,
            "title": "Update config.py with artifact_service and GCS configurations",
            "description": "Add configuration fields for artifact_service and GCS storage to support proper ADK integration",
            "status": "done",
            "dependencies": [],
            "priority": "high",
            "details": "PROBLEMA: Falta configura\u00e7\u00e3o do artifact_service e GCS\n\nREMOVER/ADICIONAR ap\u00f3s a linha 38:\n```python\n    API_KEY: str | None = Field(default=\"\")\n```\n\nADICIONAR:\n```python\n    API_KEY: str | None = Field(default=\"\")\n    \n    # Configura\u00e7\u00f5es do Artifact Service\n    artifact_storage_type: str = Field(default=\"memory\", description=\"memory ou gcs\")\n    gcs_bucket_name: str = Field(default=\"adk-professor-virtual-artifacts\")\n    \n    # Configura\u00e7\u00e3o de ambiente\n    is_production: bool = Field(default=False)\n```",
            "testStrategy": "Verify that config.py contains the new fields (artifact_storage_type, gcs_bucket_name, is_production) and that they can be properly imported and used in agent.py",
            "started_at": "2025-07-30T17:21:40Z",
            "completed_at": "2025-07-30T17:21:49Z",
            "files_modified": [
                "professor-virtual/professor_virtual/config.py"
            ]
        },
        {
            "id": 2,
            "title": "Modify agent.py to include Runner and artifact_service initialization",
            "description": "Update agent.py to properly initialize the Runner with artifact_service and session_service according to ADK standards",
            "status": "pending",
            "dependencies": [
                1
            ],
            "priority": "high",
            "details": "PROBLEMA: Falta inicializa\u00e7\u00e3o do artifact_service no Runner\n\n\u274c C\u00d3DIGO ATUAL (linhas 24-40):\n```python\nroot_agent = Agent(\n    model=configs.agent_settings.model,\n    global_instruction=\"\",\n    instruction=INSTRUCTION,\n    name=configs.agent_settings.name,\n    tools=[\n        transcrever_audio,\n        analisar_necessidade_visual,\n        analisar_imagem_educacional,\n        gerar_audio_tts,\n    ],\n    generate_content_config=configs.generate_content_config,\n    before_tool_callback=before_tool,\n    after_tool_callback=after_tool,\n    before_agent_callback=before_agent,\n    before_model_callback=rate_limit_callback,\n)\n```\n\n\u2705 SUBSTITUIR POR:\n```python\nfrom google.adk.runners import Runner\nfrom google.adk.sessions import InMemorySessionService\nfrom google.adk.artifacts import InMemoryArtifactService, GcsArtifactService\n\n# Configurar artifact service baseado no ambiente\nif configs.is_production and configs.artifact_storage_type == \"gcs\":\n    artifact_service = GcsArtifactService(bucket_name=configs.gcs_bucket_name)\nelse:\n    artifact_service = InMemoryArtifactService()\n\n# Configurar session service\nsession_service = InMemorySessionService()\n\n# Criar o agente\nroot_agent = Agent(\n    model=configs.agent_settings.model,\n    global_instruction=\"\",\n    instruction=INSTRUCTION,\n    name=configs.agent_settings.name,\n    tools=[\n        transcrever_audio,\n        analisar_necessidade_visual,\n        analisar_imagem_educacional,\n        gerar_audio_tts,\n    ],\n    generate_content_config=configs.generate_content_config,\n    before_tool_callback=before_tool,\n    after_tool_callback=after_tool,\n    before_agent_callback=before_agent,\n    before_model_callback=rate_limit_callback,\n)\n\n# Criar o Runner com artifact service\nrunner = Runner(\n    agent=root_agent,\n    app_name=configs.app_name,\n    session_service=session_service,\n    artifact_service=artifact_service  # CR\u00cdTICO: Deve ser configurado\n)\n```",
            "testStrategy": "Verify that agent.py imports Runner, InMemorySessionService, InMemoryArtifactService, and GcsArtifactService; initializes artifact_service based on environment config; creates session_service; and properly initializes the Runner with all required services"
        },
        {
            "id": 3,
            "title": "Update analisar_imagem_educacional.py to be async and fix deprecated APIs",
            "description": "Convert analisar_imagem_educacional function to async and fix deprecated session.get_artifact API and incorrect artifact data access",
            "status": "pending",
            "dependencies": [
                2
            ],
            "priority": "high",
            "details": "### PROBLEMA 1: API inexistente `session.get_artifact`\n\n**\u274c REMOVER (linhas 48-51):**\n```python\n        # Obter artefato - mant\u00e9m l\u00f3gica original\n        artifact = tool_context.session.get_artifact(nome_artefato_imagem)\n        if not artifact:\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n        # Obter artefato usando API correta\n        artifact = await tool_context.load_artifact(nome_artefato_imagem)\n        if not artifact:\n```\n\n### PROBLEMA 2: Fun\u00e7\u00e3o deve ser ass\u00edncrona\n\n**\u274c REMOVER (linha 42):**\n```python\ndef analisar_imagem_educacional(nome_artefato_imagem: str, contexto_pergunta: str, tool_context: ToolContext) -> Dict[str, Any]:\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\nasync def analisar_imagem_educacional(nome_artefato_imagem: str, contexto_pergunta: str, tool_context: ToolContext) -> Dict[str, Any]:\n```\n\n### PROBLEMA 3: Acesso incorreto aos dados do artifact\n\n**\u274c REMOVER (linha 57):**\n```python\n        imagem_bytes = artifact.content\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n        # Extrair dados do artifact corretamente\n        if hasattr(artifact, 'inline_data') and artifact.inline_data:\n            imagem_bytes = artifact.inline_data.data\n            mime_type = artifact.inline_data.mime_type\n        else:\n            return {\n                \"erro\": \"Formato de artifact inv\u00e1lido\",\n                \"sucesso\": False,\n                \"qualidade_adequada\": False\n            }\n```",
            "testStrategy": "Verify that analisar_imagem_educacional function is async, uses await tool_context.load_artifact() instead of session.get_artifact(), and correctly accesses artifact data through artifact.inline_data.data with proper error handling for invalid artifact formats"
        },
        {
            "id": 4,
            "title": "Update gerar_audio_tts.py to be async and fix deprecated APIs",
            "description": "Convert gerar_audio_tts function to async and fix deprecated session.create_artifact API usage",
            "status": "pending",
            "dependencies": [
                2
            ],
            "priority": "high",
            "details": "### PROBLEMA 1: API inexistente `session.create_artifact`\n\n**\u274c REMOVER (linhas 119-124):**\n```python\n        # Salvar usando a API existente do projeto\n        tool_context.session.create_artifact(\n            name=nome_artefato,\n            content=audio_bytes,\n            mime_type=\"audio/mpeg\"\n        )\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n        # Salvar usando a API correta do ADK\n        audio_part = types.Part.from_data(\n            data=audio_bytes,\n            mime_type=\"audio/mpeg\"\n        )\n        version = await tool_context.save_artifact(nome_artefato, audio_part)\n```\n\n### PROBLEMA 2: Fun\u00e7\u00e3o deve ser ass\u00edncrona\n\n**\u274c REMOVER (linha 41):**\n```python\ndef gerar_audio_tts(texto: str, tool_context: ToolContext, velocidade: float = 1.0, voz: str = \"pt-BR-Standard-A\") -> Dict[str, Any]:\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\nasync def gerar_audio_tts(texto: str, tool_context: ToolContext, velocidade: float = 1.0, voz: str = \"pt-BR-Standard-A\") -> Dict[str, Any]:\n```\n\n### PROBLEMA 3: Adicionar vers\u00e3o no retorno\n\n**\u274c REMOVER (linhas 142-148):**\n```python\n        return {\n            \"sucesso\": True,\n            \"nome_artefato_gerado\": nome_artefato,\n            \"tamanho_caracteres\": len(texto),\n            \"tamanho_bytes\": len(audio_bytes),\n            \"voz_utilizada\": gemini_voice,\n            \"velocidade\": velocidade\n        }\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n        return {\n            \"sucesso\": True,\n            \"nome_artefato_gerado\": nome_artefato,\n            \"versao\": version,  # Adicionar vers\u00e3o retornada\n            \"tamanho_caracteres\": len(texto),\n            \"tamanho_bytes\": len(audio_bytes),\n            \"voz_utilizada\": gemini_voice,\n            \"velocidade\": velocidade\n        }\n```",
            "testStrategy": "Verify that gerar_audio_tts function is async, uses await tool_context.save_artifact() with types.Part.from_data() instead of session.create_artifact(), and includes version field in the return object"
        },
        {
            "id": 5,
            "title": "Update transcrever_audio.py to be async and fix deprecated APIs",
            "description": "Convert transcrever_audio function to async and fix deprecated artifact loading/saving APIs, including updating the auxiliary function _buscar_audio_na_mensagem",
            "status": "pending",
            "dependencies": [
                2
            ],
            "priority": "high",
            "details": "### PROBLEMA 1: M\u00e9todo deve ser ass\u00edncrono\n\n**\u274c REMOVER (linha 46):**\n```python\ndef transcrever_audio(\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\nasync def transcrever_audio(\n```\n\n### PROBLEMA 2: load_artifact deve usar await\n\n**\u274c REMOVER (linha 61):**\n```python\n        audio_artifact = tool_context.load_artifact(nome_artefato_audio)\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n        audio_artifact = await tool_context.load_artifact(nome_artefato_audio)\n```\n\n### PROBLEMA 3: save_artifact deve usar await\n\n**\u274c REMOVER (linha 151):**\n```python\n            versao_salva = tool_context.save_artifact(filename, transcript_artifact)\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n            versao_salva = await tool_context.save_artifact(filename, transcript_artifact)\n```\n\n### PROBLEMA 4: Fun\u00e7\u00e3o auxiliar _buscar_audio_na_mensagem\n\n**\u274c REMOVER (linha 227):**\n```python\ndef _buscar_audio_na_mensagem(tool_context: ToolContext) -> Optional[Any]:\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\nasync def _buscar_audio_na_mensagem(tool_context: ToolContext) -> Optional[Any]:\n```\n\n**\u274c REMOVER (linha 65):**\n```python\n            audio_artifact = _buscar_audio_na_mensagem(tool_context)\n```\n\n**\u2705 SUBSTITUIR POR:**\n```python\n            audio_artifact = await _buscar_audio_na_mensagem(tool_context)\n```",
            "testStrategy": "Verify that transcrever_audio function is async, uses await with tool_context.load_artifact() and tool_context.save_artifact(), the auxiliary function _buscar_audio_na_mensagem is also async, and all calls to _buscar_audio_na_mensagem use await"
        },
        {
            "id": 6,
            "title": "Create artifact_handler.py for managing frontend uploads",
            "description": "Create a new file to handle file uploads from frontend and create artifacts following ADK standards",
            "status": "pending",
            "dependencies": [
                2
            ],
            "priority": "high",
            "details": "Novo Arquivo Necess\u00e1rio: `professor_virtual/artifact_handler.py`\n\nCriar este arquivo para gerenciar uploads do frontend:\n\n```python\n\"\"\"Handler para processar uploads e criar artifacts do frontend.\"\"\"\n\nimport base64\nfrom typing import Dict, Any\nfrom google.genai import types\nfrom google.adk.agents.invocation_context import InvocationContext\n\n\nasync def handle_file_upload(\n    file_data: Dict[str, Any],\n    context: InvocationContext\n) -> Dict[str, Any]:\n    \"\"\"\n    Processa upload de arquivo do frontend e cria artifact.\n    \n    Args:\n        file_data: Dict com 'content' (base64), 'mime_type' e 'filename'\n        context: Contexto da invoca\u00e7\u00e3o ADK\n        \n    Returns:\n        Dict com informa\u00e7\u00f5es do artifact criado\n    \"\"\"\n    try:\n        # Decodificar base64 se necess\u00e1rio\n        if isinstance(file_data['content'], str):\n            content_bytes = base64.b64decode(file_data['content'])\n        else:\n            content_bytes = file_data['content']\n            \n        # Criar Part do arquivo\n        artifact = types.Part.from_data(\n            data=content_bytes,\n            mime_type=file_data['mime_type']\n        )\n        \n        # Salvar artifact\n        version = await context.save_artifact(\n            filename=file_data['filename'],\n            artifact=artifact\n        )\n        \n        return {\n            \"success\": True,\n            \"filename\": file_data['filename'],\n            \"version\": version,\n            \"size\": len(content_bytes)\n        }\n        \n    except Exception as e:\n        return {\n            \"success\": False,\n            \"error\": str(e)\n        }\n```",
            "testStrategy": "Verify that artifact_handler.py exists in professor_virtual directory, contains handle_file_upload async function with proper imports (base64, types from google.genai, InvocationContext), handles base64 decoding, creates artifacts using types.Part.from_data(), saves artifacts with context.save_artifact(), and returns success/error responses with proper fields"
        },
        {
            "id": 7,
            "title": "Frontend Integration Guidelines (Documentation/Comments)",
            "description": "Document the frontend integration requirements and data format specifications for proper communication with the ADK backend",
            "status": "pending",
            "dependencies": [
                6
            ],
            "priority": "high",
            "details": "## Modifica\u00e7\u00f5es no Frontend (Orienta\u00e7\u00f5es)\n\n### Frontend deve enviar dados no formato:\n\n```json\n{\n  \"action\": \"upload_file\",\n  \"file_data\": {\n    \"content\": \"base64_encoded_content\",\n    \"mime_type\": \"audio/wav\",\n    \"filename\": \"pergunta_aluno_123.wav\"\n  },\n  \"session_id\": \"session_abc\",\n  \"user_id\": \"user_123\"\n}\n```\n\n### Frontend N\u00c3O deve:\n- Esperar que o Runner crie artifacts automaticamente\n- Enviar arquivos bin\u00e1rios diretamente no corpo da requisi\u00e7\u00e3o\n- Usar APIs do ADK diretamente (n\u00e3o h\u00e1 SDK Flutter oficial)\n\n### Frontend DEVE:\n- Converter arquivos para base64 antes de enviar\n- Incluir sempre o MIME type correto\n- Aguardar confirma\u00e7\u00e3o com filename e version do backend",
            "testStrategy": "Verify that frontend code (when implemented) follows these guidelines: sends data in the specified JSON format with base64 encoding, includes all required fields (action, file_data with content/mime_type/filename, session_id, user_id), does not expect automatic artifact creation, does not send binary data directly, and properly waits for backend confirmation with filename and version"
        },
        {
            "id": 11,
            "title": "Review and update all helper functions and callbacks for async/await compliance",
            "description": "Ensure all internal helper functions and callbacks that interact with artifacts are properly converted to async and use await, as this is a critical step not covered by the main tool file modifications.",
            "status": "pending",
            "dependencies": [
                3,
                4,
                5
            ],
            "priority": "high",
            "details": "### Verifica\u00e7\u00e3o **await** em helpers\n\nAl\u00e9m dos arquivos listados, revise **todos** os *helpers* internos e callbacks para garantir:\n\n* fun\u00e7\u00f5es que chamam `load_artifact` / `save_artifact` \u2192 `async def \u2026`\n* chamadas precedidas de `await`\n\n> **Checklist r\u00e1pido**\n>\n> * [_buscar_audio_na_mensagem] \u2705 j\u00e1 alterado\n> * [_get_audio_hash] \u2014 permanece s\u00edncrono (n\u00e3o faz I/O)\n> * qualquer callback em `before_tool` / `after_tool` que use artifacts \u2192 tornar async",
            "testStrategy": "Manually review all helper functions and callbacks (e.g., in `before_tool`, `after_tool`) to confirm that any function calling `load_artifact` or `save_artifact` is defined as `async def` and that the calls are preceded by `await`. Verify that `_get_audio_hash` remains synchronous as specified."
        }
    ]
}